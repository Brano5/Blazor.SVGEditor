<g>
    <path d="@Path.Instructions.AsString()" fill="@Path.Fill" stroke="@Path.Stroke" stroke-width="@Path.StrokeWidth" @onmousedown="Select" />
    @if (Path.Selected)
    {
        @for (int i = 0; i < Path.Instructions.Count; i++)
        {
            var j = i;
            if (Path.Instructions[i]
                is LineInstruction
                or MoveInstruction
                or HorizontalLineInstruction
                or VerticalLineInstruction
                or CubicBézierCurveInstruction
                or ShorthandCubicBézierCurveInstruction)
            {
                <circle @onmousedown="() => AnchorSelect(j, -1)" cx="@Path.Instructions[i].EndPosition.x" cy="@Path.Instructions[i].EndPosition.y" r="6" stroke-width="2" stroke="black" fill="transparent" />
            }
            if (Path.Instructions[i] is CubicBézierCurveInstruction cubicCurve)
            {
                <line x1="@cubicCurve.StartPosition.x" y1="@cubicCurve.StartPosition.y" x2="@cubicCurve.ControlPoints[0].x" y2="@cubicCurve.ControlPoints[0].y" stroke-dasharray="4" stroke="black" stroke-width="2" />
                <line x1="@cubicCurve.ControlPoints[1].x" y1="@cubicCurve.ControlPoints[1].y" x2="@cubicCurve.EndPosition.x" y2="@cubicCurve.EndPosition.y" stroke-dasharray="4" stroke="black" stroke-width="2" />
            }
            if (Path.Instructions[i].GetType().IsSubclassOf(typeof(BaseControlPointPathInstruction)))
            {
                var ControlPointInstruction = (BaseControlPointPathInstruction)Path.Instructions[i];
                for (int k = 0; k < ControlPointInstruction.ControlPoints.Count; k++)
                {
                    var anchor = k;
                    <circle @onmousedown="() => AnchorSelect(j, anchor)" cx="@ControlPointInstruction.ControlPoints[k].x" cy="@ControlPointInstruction.ControlPoints[k].y" r="6" stroke-width="2" stroke="black" fill="transparent" />
                }
            }
            if (Path.Instructions[i] is ShorthandCubicBézierCurveInstruction shorthandCubicCurve)
            {
                <line x1="@shorthandCubicCurve.StartPosition.x" y1="@shorthandCubicCurve.StartPosition.y" x2="@shorthandCubicCurve.ReflectedPreviousInstructionsLastControlPoint.x" y2="@shorthandCubicCurve.ReflectedPreviousInstructionsLastControlPoint.y" stroke-dasharray="4" stroke="grey" stroke-width="2" />
                <line x1="@shorthandCubicCurve.ControlPoints[0].x" y1="@shorthandCubicCurve.ControlPoints[0].y" x2="@shorthandCubicCurve.EndPosition.x" y2="@shorthandCubicCurve.EndPosition.y" stroke-dasharray="4" stroke="black" stroke-width="2" />
                var ControlPointInstruction = (BaseControlPointPathInstruction)Path.Instructions[i];
                <circle @onmousedown="() => AnchorSelect(j, -2)" cx="@ControlPointInstruction.ReflectedPreviousInstructionsLastControlPoint.x" cy="@ControlPointInstruction.ReflectedPreviousInstructionsLastControlPoint.y" r="6" stroke-width="2" stroke="grey" fill="transparent" />
            }
        }
    }
</g>

@code {
    [Parameter]
    public Path Path { get; set; }

    public void AnchorSelect(int segment, int anchor)
    {
        if (Path.EditMode != EditMode.Add)
        {
            Path.CurrentInstruction = segment;
            Path.CurrentAnchor = anchor;
            Path.EditMode = EditMode.MoveAnchor;
        }
    }

    public void Select(MouseEventArgs eventArgs)
    {
        if (Path.SVG.CurrentShape == null || Path.SVG.CurrentShape.EditMode == EditMode.None)
        {
            Path.SVG.CurrentShape = Path;
            Path.Panner = (x: eventArgs.OffsetX, y: eventArgs.OffsetY);
            Path.EditMode = EditMode.Move;
        }
    }
}
