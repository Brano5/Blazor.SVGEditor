@using KristofferStrube.Blazor.SVGEditor.PathDataSequences
@inherits ShapeEditor<Path>

<ContextMenuTrigger MenuId="SVGMenu" WrapperTag="g" Data=@SVGElement StopPropagation=@(!SVGElement.IsChildElement)>
    <g transform="translate(@SVGElement.SVG.Translate.x.AsString() @SVGElement.SVG.Translate.y.AsString()) scale(@SVGElement.SVG.Scale.AsString())">
        <path tabindex="@(SVGElement.IsChildElement ? -1 : 0)"
              @onfocusin="FocusElement"
              @onfocusout="UnfocusElement"
              @ref=ElementReference
              d="@SVGElement.Instructions.AsString()"
              fill="@SVGElement.Fill"
              stroke="@SVGElement.Stroke"
              stroke-width="@SVGElement.StrokeWidth"
              @onpointerdown="Select"
              @onkeyup="KeyUp"
              @onselectstart:stopPropagation="true"
              class="unselectable">
            @foreach (BaseAnimate animate in SVGElement.AnimationElements)
            {
                var Parameters = new Dictionary<string, object> { { "SVGElement", animate } };
                <DynamicComponent Type=animate.Presenter Parameters=Parameters />
            }
        </path>
    </g>
    @if (SVGElement.Selected && SVGElement.SVG.EditMode is not (EditMode.Add or EditMode.Scale))
    {
        @for (int i = 0; i < SVGElement.Instructions.Count; i++)
        {
            var j = i;
            switch (SVGElement.Instructions[i])
            {
                case EllipticalArcInstruction ellipticalArc:
                    <Anchor Color="black" OnPointerDown="() => AnchorSelect(j, 0)" Position=ellipticalArc.ControlPointYPos />
                    <Anchor Color="black" OnPointerDown="() => AnchorSelect(j, 1)" Position=ellipticalArc.ControlPointYNeg />
                    <Anchor Color="black" OnPointerDown="() => AnchorSelect(j, 2)" Position=ellipticalArc.ControlPointXPos />
                    <Anchor Color="black" OnPointerDown="() => AnchorSelect(j, 3)" Position=ellipticalArc.ControlPointXNeg />
                    <ellipse transform="translate(@SVGElement.SVG.Translate.x.AsString() @SVGElement.SVG.Translate.y.AsString()) rotate(@(ellipticalArc.XAxisRotation.AsString()) @((ellipticalArc.Center.x*SVGElement.SVG.Scale).AsString()) @((ellipticalArc.Center.y*SVGElement.SVG.Scale).AsString()))" cx="@((ellipticalArc.Center.x*SVGElement.SVG.Scale).AsString())" cy="@((ellipticalArc.Center.y*SVGElement.SVG.Scale).AsString())" rx="@((ellipticalArc.EllipseRadi.Rx*SVGElement.SVG.Scale).AsString())" ry="@((ellipticalArc.EllipseRadi.Ry*SVGElement.SVG.Scale).AsString())" style="pointer-events: none;" fill="none" stroke-dasharray="4" stroke="grey" stroke-width="2"></ellipse>
                    break;
                case CubicBézierCurveInstruction cubicCurve:
                    <StripedLine Color="black" From=cubicCurve.StartPosition To=cubicCurve.ControlPoints[0] />
                    <StripedLine Color="black" From=cubicCurve.ControlPoints[1] To=cubicCurve.EndPosition />

                    var withinRangeOfCubicCurvePoints = cubicCurve.ControlPoints[0].WithinRangeOf(cubicCurve.ControlPoints[1], 5 / SVGElement.SVG.Scale);
                    <Anchor Color=@(withinRangeOfCubicCurvePoints ? "blue" : "black")
            CircleThickness=@(withinRangeOfCubicCurvePoints ? 4 : 2)
            OnPointerDown="() => AnchorSelect(j, 0)"
            Position=cubicCurve.ControlPoints[0] />
                    <Anchor Color=@(withinRangeOfCubicCurvePoints ? "blue" : "black")
            CircleThickness=@(withinRangeOfCubicCurvePoints ? 4 : 2)
            OnPointerDown="() => AnchorSelect(j, 1)"
            Position=cubicCurve.ControlPoints[1] />
                    break;
                case QuadraticBézierCurveInstruction quadraticCurve:
                    <StripedLine Color="black" From=quadraticCurve.StartPosition To=quadraticCurve.ControlPoints[0] />
                    <StripedLine Color="black" From=quadraticCurve.ControlPoints[0] To=quadraticCurve.EndPosition />
                    <Anchor Color="black" OnPointerDown="() => AnchorSelect(j, 0)" Position=quadraticCurve.ControlPoints[0] />
                    break;
                case ShorthandCubicBézierCurveInstruction shorthandCubicCurve:
                    <StripedLine Color="black" From=shorthandCubicCurve.ControlPoints[0] To=shorthandCubicCurve.EndPosition />

                    var withinRangeOfShorthandCubicCurvePoints = shorthandCubicCurve.ReflectedPreviousInstructionsLastControlPoint.WithinRangeOf(shorthandCubicCurve.ControlPoints[0], 5 / SVGElement.SVG.Scale);
                    if (shorthandCubicCurve.PreviousInstruction is not ShorthandQuadraticBézierCurveInstruction)
                    {
                        <StripedLine Color="grey" From=shorthandCubicCurve.StartPosition To=shorthandCubicCurve.ReflectedPreviousInstructionsLastControlPoint />
                        <Anchor Color=@(withinRangeOfShorthandCubicCurvePoints ? "blue" : "grey")
            CircleThickness=@(withinRangeOfShorthandCubicCurvePoints ? 4 : 2)
            OnPointerDown="() => AnchorSelect(j, -2)"
            Position=shorthandCubicCurve.ReflectedPreviousInstructionsLastControlPoint />
                    }
                    <Anchor Color=@(withinRangeOfShorthandCubicCurvePoints ? "blue" : "black")
            CircleThickness=@(withinRangeOfShorthandCubicCurvePoints ? 4 : 2)
            OnPointerDown="() => AnchorSelect(j, 0)"
            Position=shorthandCubicCurve.ControlPoints[0] />
                    break;
                case ShorthandQuadraticBézierCurveInstruction shorthandQuadraticCurve:
                    <StripedLine Color="grey" From=shorthandQuadraticCurve.StartPosition To=shorthandQuadraticCurve.ReflectedPreviousInstructionsLastControlPoint />
                    <StripedLine Color="grey" From=shorthandQuadraticCurve.EndPosition To=shorthandQuadraticCurve.ReflectedPreviousInstructionsLastControlPoint />
                    <Anchor Color="grey" OnPointerDown="() => AnchorSelect(j, -2)" Position=shorthandQuadraticCurve.ReflectedPreviousInstructionsLastControlPoint />
                    break;
            }
            if (SVGElement.Instructions[i] is not ClosePathInstruction)
            {
                <Anchor Color="black" OnPointerDown="() => AnchorSelect(j, -1)" Position=SVGElement.Instructions[i].EndPosition />
            }
        }
    }
    else if (SVGElement.Selected && SVGElement.SVG.EditMode == EditMode.Scale)
    {
        <BoxScaler Box=SVGElement.BoundingBox AnchorOnPointerDown=AnchorSelect />
    }
</ContextMenuTrigger>

@code {
    public void AnchorSelect(int segment, int anchor)
    {
        if (SVGElement.SVG.EditMode is EditMode.Scale or EditMode.Move or EditMode.None)
        {
            SVGElement.SVG.CurrentAnchor = anchor;
            SVGElement.SVG.CurrentAnchorShape = SVGElement;
        }
        if (SVGElement.SVG.EditMode is EditMode.Move or EditMode.None)
        {
            SVGElement.CurrentInstruction = segment;
            SVGElement.SVG.EditMode = EditMode.MoveAnchor;
        }
    }
}